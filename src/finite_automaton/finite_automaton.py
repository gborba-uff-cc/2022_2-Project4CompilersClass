'''
DFA definition and some DFA operations
'''

import itertools
import typing

State: typing.TypeAlias = str
Symbol: typing.TypeAlias = str
DFATransitionFunction: typing.TypeAlias = dict[tuple[State, Symbol], State]
NFATransitionFunction: typing.TypeAlias = dict[tuple[State,Symbol], frozenset[State]]


class FA():
    def __init__(
        self,
        Q: typing.Iterable[State],
        Sigma: typing.Iterable[Symbol],
        q0: State,
        F: typing.Iterable[Symbol]
    ) -> None:
        self.Q: frozenset[State] = frozenset(Q)
        self.alphabet: frozenset[Symbol] = frozenset(Sigma)
        self.q0: State = q0
        self.F: frozenset[State] = frozenset(F)


class DFA(FA):
    def __init__(
        self,
        Q: typing.Iterable[State],
        Sigma: typing.Iterable[Symbol],
        delta: DFATransitionFunction,
        q0: State,
        F: typing.Iterable[Symbol]
    ) -> None:
        super().__init__(Q, Sigma, q0, F)
        self.transitionFunction: DFATransitionFunction = delta

    def __str__(self) -> str:
        Q = '\n'.join(sorted((f"\t{q}" for q in self.Q)))
        Sigma = '\n'.join(sorted((f"\t{{\'{', '.join(s)}\'}}" for s in self.alphabet)))
        delta = '\n'.join((f'\t{k} -> {v}' for k,v in self.transitionFunction.items()))
        F = '\n'.join(sorted((f"\t{q}" for q in self.F)))
        return f'Q: {Q}\nΣ: {Sigma}\nδ: {delta}\nq0: \t{self.q0}\nF: {F}'

    def Accept(self, word: str) -> bool:
        cur_state = self.q0
        i_char = 0
        len_w = len(word)
        while i_char < len_w:
            cur_state = self.transitionFunction[cur_state, word[i_char]]
            i_char += 1
        # NOTE - acceptance condition
        return (i_char == len(word)) and (cur_state in self.F)

    def Complement(self) -> 'DFA':
        """
        Return the complemet of L(`self`).

        *L(FA) is the language recognized by the finite automaton FA.
        """
        return DFA(
            Q=self.Q,
            Sigma=self.alphabet,
            delta=self.transitionFunction,
            q0=self.q0,
            F=self.Q - self.F
        )

    def Intersection(self, other: 'DFA') -> 'DFA':
        """
        Return a DFA that recognizes L(`self`) intersection L(`other`).

        Both DFA should have the same alphabet.

        *L(FA) is the language recognized by the finite automaton FA.
        """
        if len(self.alphabet ^ other.alphabet) != 0:
            RuntimeError("can't do intersection, alphabets are different")

        newQ, newTransitionFunction = self.__IntersectionAndUnionCommon(other)
        Q = frozenset(map(str, newQ))
        q0=str((self.q0,other.q0))
        F = frozenset(
            (str(pair) for pair in itertools.product(self.F, other.F)))
        return DFA(
            Q=Q,
            Sigma=self.alphabet,
            delta=newTransitionFunction,
            q0=q0,
            F=F
        )

    def Union(self, other: 'DFA') -> 'DFA':
        """
        Return a DFA that recognizes L(`self`) union L(`other`).

        Both DFA should have the same alphabet.

        *L(FA) is the language recognized by the finite automaton FA.
        """
        if len(self.alphabet ^ other.alphabet) != 0:
            RuntimeError("can't do union, alphabets are different")

        newQ, newTransitionFunction = self.__IntersectionAndUnionCommon(other)
        Q = frozenset(map(str, newQ))
        q0=str((self.q0,other.q0))
        aux = []
        aux.extend([str(pair) for pair in itertools.product(self.F, other.Q)])
        aux.extend([str(pair) for pair in itertools.product(self.Q, other.F)])
        F = frozenset(aux)
        return DFA(
            Q=Q,
            Sigma=self.alphabet,
            delta=newTransitionFunction,
            q0=q0,
            F=F
        )

    def __IntersectionAndUnionCommon(
            self,
            other: 'DFA'
        ) -> tuple[typing.Iterable[tuple[State,State]], DFATransitionFunction]:
        """
        Return the common part of the new DFA generated by union or
        intersection.
        """
        Q = list((
            pair for pair in itertools.product(self.Q, other.Q)))
        transitionFunction: DFATransitionFunction = {}
        for ((m1q, m2q), symbol) in itertools.product(Q, self.alphabet):
            v = (
                self.transitionFunction[m1q, symbol],
                other.transitionFunction[m2q, symbol]
            )
            k = (m1q, m2q)
            transitionFunction[(str(k), symbol)] = str(v)
        return (Q, transitionFunction)

    def toRegularExpression(self):
        """
        Return the regular expression associated to self.
        """
        L: dict[State, dict[State,set[Symbol]]] = {}
        for ((qa,s),qb) in self.transitionFunction.items():
            Lqa = L.setdefault(qa,dict())
            Lqb = Lqa.setdefault(qb,set())
            Lqb.add(s)
            # NOTE - add epsilon to languages related to F
            if qa in self.F:
                Lqa['']=set(('',))

        Lq0 = self.__RegExp(L,self.q0)
        return Lq0

    def __RegExp(
        self,
        L: dict[State, dict[State,set[Symbol]]],
        q: State) -> str:
        """
        Recursively return the regular expression associated with `q` given the
        initial set `L` of generated languages.
        """
        L = self.__RemoveDeadLanguages(L)
        ERReservedSymbols: frozenset[Symbol] = frozenset('( ) | *'.split())
        def __SetSymbolsToStr(symbolsSet: frozenset[Symbol]|set[Symbol]) -> str:
            symbols: typing.Iterable[Symbol] = []
            for s in symbolsSet:
                if s in ERReservedSymbols:
                    symbols.append(f'\\{s}')
                else:
                    symbols.append(s)
            lenSymbolsSet = len(symbolsSet)
            return f"{'(' if lenSymbolsSet > 1 else ''}{'|'.join(symbols)}{')' if lenSymbolsSet > 1 else ''}"

        ardenGenerated: str = ''
        if q in L[q].keys():
            symbolsSet = L[q][q]
            symbols = __SetSymbolsToStr(symbolsSet)
            lenSymbolsSet = len(symbolsSet)
            ardenGenerated = \
                f"{'(' if lenSymbolsSet > 1 else ''}{symbols}{')' if lenSymbolsSet > 1 else ''}*"
            del L[q][q]

        LGenerated: typing.Iterable[str] = []
        for qo, symbolsSet in L[q].items():
            if qo:
                symbols = __SetSymbolsToStr(symbolsSet)
                LGenerated.append(f'{symbols}{self.__RegExp(L,qo)}')
        lenLGenerated = len(LGenerated)
        generatedRE = f"{'('if lenLGenerated > 1 else ''}{'|'.join(LGenerated)}{')'if lenLGenerated > 1 else ''}"
        return f"{ardenGenerated}{generatedRE}"

    def __RemoveDeadLanguages(
        self,
        L: dict[State, dict[State,set[Symbol]]]
    ) -> dict[State, dict[State,set[Symbol]]]:
        """
        Remove dead languages generated starting by an state.
        """
        searchDeadLanguage = True
        deadLanguage = ''
        while searchDeadLanguage:
            searchDeadLanguage, deadLanguage = self.__FindDeadLanguage(L)
            if searchDeadLanguage:
                del L[deadLanguage]
                for q in L.keys():
                    L[q].pop(deadLanguage, None)
        return L

    def __FindDeadLanguage(
        self,
        L: dict[State, dict[State,set[Symbol]]]
    ) -> tuple[bool, State]:
        """
        Return a state that do not leave itself.
        """
        for q in L.keys():
            if len(L[q]) == 0 or all(map(lambda elem: elem == q, L[q].keys())):
                return True, q
        return False, ''

    def Minimize(self) -> 'DFA':
        """
        Minimize a DFA returning a new DFA with the minimum necessary states and
        transitions.
        """
        T: typing.Sequence[frozenset[State]] = []
        T.append(frozenset(self.F))
        T.append(frozenset(self.Q-self.F))

        sigmaSequence = sorted(list(self.alphabet))

        iP = 0
        while iP < len(T):
            # NOTE - partitions after split
            S = self.__MinimizeSplit(T[iP], T, sigmaSequence)
            # NOTE - growing like this to avoid shifts on list
            T[iP]=S[0]  # NOTE - instead of poping the element, update its place
            T.extend(S[1:])  # NOTE - growing the list on tail should be cheaper
            if len(S) > 1:  # NOTE - restart because split happened
                iP = 0
            elif len(S) == 1:  # NOTE - continue searching for split
                iP += 1
            else:
                raise RuntimeError('Split returned less than 1 set.')

        Q: typing.Iterable[State] = (f"{{\'{', '.join(q)}\'}}" for q in T)
        transitionFunction: DFATransitionFunction = {}
        for q in T:
            for s in self.alphabet:
                transitionFunction[(f"{{\'{', '.join(q)}\'}}", s)] = f"{{\'{', '.join(self.__MinimizeWholePartitionGoes(q, s, T))}\'}}"
        q0: State = tuple((f"{{\'{', '.join(q)}\'}}" for q in T if self.q0 in q))[0]
        F: typing.Iterable[State] = (
            f"{{\'{', '.join(q)}\'}}" for q in T if len(self.F & q))

        return DFA(
            Q=Q,
            Sigma=self.alphabet,
            delta=transitionFunction,
            q0=q0,
            F=F
        )

    def __MinimizeSplit(
        self,
        aPartition: frozenset[State],
        thePartitions: typing.Sequence[frozenset[State]],
        anAlphabet: typing.Sequence
    )->typing.Sequence[frozenset[State]]:
        """
        Verify for each symbol in `alphabet` where each state in `partition`
        goes  and split the current `partition` if any state make the current
        `partition` point to 2 or more other partitions
        """
        fromStateToPartition: dict[State, frozenset[State]] = {}
        fromPartitionToState: dict[frozenset[State],set[State]] = {}
        for symbol in anAlphabet:
            fromStateToPartition.clear()
            for state in aPartition:
                stateGoes = self.transitionFunction[state,symbol]
                for partition in thePartitions:
                    if stateGoes in partition:
                        fromStateToPartition[state]=partition
                        break
            # NOTE - states by partition
            fromPartitionToState.clear()
            for k, v in fromStateToPartition.items():
                fromPartitionToState.setdefault(v, set())
                fromPartitionToState[v].add(k)
            if len(fromPartitionToState) > 1:
                return [frozenset(v) for v in fromPartitionToState.values()]
        return [frozenset(v) for v in fromPartitionToState.values()]

    def __MinimizeWholePartitionGoes(
        self,
        aPartition: frozenset[State],
        aSymbol: Symbol,
        thePartitions: typing.Sequence[frozenset[State]],
    ) -> frozenset[State]:
        """
        Find the partition where `aPartition` points to.
        """
        # NOTE - one state will do
        for state in aPartition:
            stateGoes = self.transitionFunction[state,aSymbol]
            for partition in thePartitions:
                if stateGoes in partition:
                    return partition
        raise RuntimeError('Destination partition not found for 'f'\n{aPartition=}'f'\n{aSymbol=}')


if __name__ == '__main__':
    def CreateDFA2aExactly():
        return DFA(
            Q=set('q1 q2 q3 q4'.split()),
            Sigma=set('a b'.split()),
            delta={
                ('q1', 'a'): 'q2',
                ('q1', 'b'): 'q1',
                ('q2', 'a'): 'q3',
                ('q2', 'b'): 'q2',
                ('q3', 'a'): 'q4',
                ('q3', 'b'): 'q3',
                ('q4', 'a'): 'q4',
                ('q4', 'b'): 'q4',
            },
            q0='q1',
            F={'q3'}
        )

    def CreateDFA2bAtLeast():
        return DFA(
            Q=set('s1 s2 s3'.split()),
            Sigma=set('a b'.split()),
            delta={
                ('s1', 'a'): 's1',
                ('s1', 'b'): 's2',
                ('s2', 'a'): 's2',
                ('s2', 'b'): 's3',
                ('s3', 'a'): 's3',
                ('s3', 'b'): 's3',
            },
            q0='s1',
            F={'s3'}
        )

    def CreateDFAac_bc():
        return DFA(
            Q=[f'q{i}' for i in range(5)]+['qe'],
            Sigma='a b c'.split(),
            delta={
                ('q0', 'a'): 'q1',
                ('q0', 'b'): 'q2',
                ('q0', 'c'): 'qe',
                ('q1', 'a'): 'qe',
                ('q1', 'b'): 'qe',
                ('q1', 'c'): 'q3',
                ('q2', 'a'): 'qe',
                ('q2', 'b'): 'qe',
                ('q2', 'c'): 'q4',
                ('q3', 'a'): 'qe',
                ('q3', 'b'): 'qe',
                ('q3', 'c'): 'qe',
                ('q4', 'a'): 'qe',
                ('q4', 'b'): 'qe',
                ('q4', 'c'): 'qe',
                ('qe', 'a'): 'qe',
                ('qe', 'b'): 'qe',
                ('qe', 'c'): 'qe',
            },
            q0='q0',
            F={'q3','q4'}
        )

    M1 = CreateDFA2aExactly()
    M2 = CreateDFA2bAtLeast()
    M3 = CreateDFAac_bc()
    machines = [
        M1,                  # NOTE - M00
        M1.Minimize(),       # NOTE - M01
        M2,                  # NOTE - M02
        M2.Minimize(),       # NOTE - M03
        M3,                  # NOTE - M04
        M3.Minimize(),       # NOTE - M05
        M1.Complement(),     # NOTE - M06
        M2.Complement(),     # NOTE - M07
        M1.Union(M2),        # NOTE - M08
        M1.Intersection(M2)  # NOTE - M09
    ]

    for i, M in enumerate(machines):
        print()
        print(f'''M{i:02}.toRegularExpression()=\n\t{M.toRegularExpression()}''')
        for w in [''.join(tuple4) for tuple4 in itertools.product(('a','b'),repeat=4)]:
            print(f'''M{i}.Accept('{w}')={M.Accept(w)}''')
