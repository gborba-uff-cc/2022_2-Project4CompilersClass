'''
DFA definition and some DFA operations
'''

import itertools
import typing

State: typing.TypeAlias = str
Symbol: typing.TypeAlias = str
DFATransitionFunction: typing.TypeAlias = dict[tuple[State, Symbol], State]
NFATransitionFunction: typing.TypeAlias = dict[tuple[State,Symbol], frozenset[State]]


class FA():
    def __init__(
        self,
        Q: typing.Iterable[State],
        Sigma: typing.Iterable[Symbol],
        q0: State,
        F: typing.Iterable[Symbol]
    ) -> None:
        self.Q: frozenset[State] = frozenset(Q)
        self.alphabet: frozenset[Symbol] = frozenset(Sigma)
        self.q0: State = q0
        self.F: frozenset[State] = frozenset(F)


class DFA(FA):
    def __init__(
        self,
        Q: typing.Iterable[State],
        Sigma: typing.Iterable[Symbol],
        delta: DFATransitionFunction,
        q0: State,
        F: typing.Iterable[Symbol]
    ) -> None:
        super().__init__(Q, Sigma, q0, F)
        self.transitionFunction: DFATransitionFunction = delta

    def Accept(self, word: str) -> bool:
        cur_state = self.q0
        i_char = 0
        len_w = len(word)
        while i_char < len_w:
            cur_state = self.transitionFunction[cur_state, word[i_char]]
            i_char += 1
        # NOTE - acceptance condition
        return (i_char == len(word)) and (cur_state in self.F)

    def Complement(self) -> 'DFA':
        """
        Return the complemet of L(`self`).

        *L(FA) is the language recognized by the finite automaton FA.
        """
        return DFA(
            Q=self.Q,
            Sigma=self.alphabet,
            delta=self.transitionFunction,
            q0=self.q0,
            F=self.Q - self.F
        )

    def Intersection(self, other: 'DFA') -> 'DFA':
        """
        Return a DFA that recognizes L(`self`) intersection L(`other`).

        Both DFA should have the same alphabet.

        *L(FA) is the language recognized by the finite automaton FA.
        """
        if len(self.alphabet ^ other.alphabet) != 0:
            RuntimeError("can't do intersection, alphabets are different")

        newQ, newTransitionFunction = self.__IntersectionAndUnionCommon(other)
        Q = frozenset(map(str, newQ))
        q0=str((self.q0,other.q0))
        F = frozenset(
            (str(pair) for pair in itertools.product(self.F, other.F)))
        return DFA(
            Q=Q,
            Sigma=self.alphabet,
            delta=newTransitionFunction,
            q0=q0,
            F=F
        )

    def Union(self, other: 'DFA') -> 'DFA':
        """
        Return a DFA that recognizes L(`self`) union L(`other`).

        Both DFA should have the same alphabet.

        *L(FA) is the language recognized by the finite automaton FA.
        """
        if len(self.alphabet ^ other.alphabet) != 0:
            RuntimeError("can't do union, alphabets are different")

        newQ, newTransitionFunction = self.__IntersectionAndUnionCommon(other)
        Q = frozenset(map(str, newQ))
        q0=str((self.q0,other.q0))
        aux = []
        aux.extend([str(pair) for pair in itertools.product(self.F, other.Q)])
        aux.extend([str(pair) for pair in itertools.product(self.Q, other.F)])
        F = frozenset(aux)
        return DFA(
            Q=Q,
            Sigma=self.alphabet,
            delta=newTransitionFunction,
            q0=q0,
            F=F
        )

    def __IntersectionAndUnionCommon(
            self,
            other: 'DFA'
        ) -> tuple[typing.Iterable[tuple[State,State]], DFATransitionFunction]:
        """
        Return the common part of the new DFA generated by union or
        intersection.
        """
        Q = list((
            pair for pair in itertools.product(self.Q, other.Q)))
        transitionFunction: DFATransitionFunction = {}
        for ((m1q, m2q), symbol) in itertools.product(Q, self.alphabet):
            v = (
                self.transitionFunction[m1q, symbol],
                other.transitionFunction[m2q, symbol]
            )
            k = (m1q, m2q)
            transitionFunction[(str(k), symbol)] = str(v)
        return (Q, transitionFunction)

    def toRegularExpression(self):
        """
        Return the regular expression associated to self.
        """
        L: dict[State, dict[State,set[Symbol]]] = {}
        for ((qa,s),qb) in self.transitionFunction.items():
            Lqa = L.setdefault(qa,dict())
            Lqb = Lqa.setdefault(qb,set())
            Lqb.add(s)
            # NOTE - add epsilon to languages related to F
            if qa in self.F:
                Lqa['']=set(('',))

        Lq0 = self.__RegExp(L,self.q0)
        return Lq0

    def __RegExp(
        self,
        L: dict[State, dict[State,set[Symbol]]],
        q: State) -> str:
        """
        Recursively return the regular expression associated with `q` given the
        initial set `L` of generated languages.
        """
        L = self.__RemoveDeadLanguages(L)
        ERReservedSymbols: frozenset[Symbol] = frozenset('( ) | *'.split())
        def __SetSymbolsToStr(symbolsSet: frozenset[Symbol]|set[Symbol]) -> str:
            symbols: typing.Iterable[Symbol] = []
            for s in symbolsSet:
                if s in ERReservedSymbols:
                    symbols.append(f'\\{s}')
                else:
                    symbols.append(s)
            lenSymbolsSet = len(symbolsSet)
            return f"{'(' if lenSymbolsSet > 1 else ''}{'|'.join(symbols)}{')' if lenSymbolsSet > 1 else ''}"

        ardenGenerated: str = ''
        if q in L[q].keys():
            symbolsSet = L[q][q]
            symbols = __SetSymbolsToStr(symbolsSet)
            lenSymbolsSet = len(symbolsSet)
            ardenGenerated = \
                f"{'(' if lenSymbolsSet > 1 else ''}{symbols}{')' if lenSymbolsSet > 1 else ''}*"
            del L[q][q]

        LGenerated: typing.Iterable[str] = []
        for qo, symbolsSet in L[q].items():
            if qo:
                symbols = __SetSymbolsToStr(symbolsSet)
                LGenerated.append(f'{symbols}{self.__RegExp(L,qo)}')
        lenLGenerated = len(LGenerated)
        generatedRE = f"{'('if lenLGenerated > 1 else ''}{'|'.join(LGenerated)}{')'if lenLGenerated > 1 else ''}"
        return f"{ardenGenerated}{generatedRE}"

    def __RemoveDeadLanguages(
        self,
        L: dict[State, dict[State,set[Symbol]]]
    ) -> dict[State, dict[State,set[Symbol]]]:
        """
        Remove dead languages generated starting by an state.
        """
        searchDeadLanguage = True
        deadLanguage = ''
        while searchDeadLanguage:
            searchDeadLanguage, deadLanguage = self.__FindDeadLanguage(L)
            if searchDeadLanguage:
                del L[deadLanguage]
                for q in L.keys():
                    L[q].pop(deadLanguage, None)
        return L

    def __FindDeadLanguage(
        self,
        L: dict[State, dict[State,set[Symbol]]]
    ) -> tuple[bool, State]:
        """
        Return a state that do not leave itself.
        """
        for q in L.keys():
            if len(L[q]) == 0 or all(map(lambda elem: elem == q, L[q].keys())):
                return True, q
        return False, ''


if __name__ == '__main__':
    def CreateDFA2aExactly():
        return DFA(
            Q=set('q1 q2 q3 q4'.split()),
            Sigma=set('a b'.split()),
            delta={
                ('q1', 'a'): 'q2',
                ('q1', 'b'): 'q1',
                ('q2', 'a'): 'q3',
                ('q2', 'b'): 'q2',
                ('q3', 'a'): 'q4',
                ('q3', 'b'): 'q3',
                ('q4', 'a'): 'q4',
                ('q4', 'b'): 'q4',
            },
            q0='q1',
            F={'q3'}
        )

    def CreateDFA2bAtLeast():
        return DFA(
            Q=set('s1 s2 s3'.split()),
            Sigma=set('a b'.split()),
            delta={
                ('s1', 'a'): 's1',
                ('s1', 'b'): 's2',
                ('s2', 'a'): 's2',
                ('s2', 'b'): 's3',
                ('s3', 'a'): 's3',
                ('s3', 'b'): 's3',
            },
            q0='s1',
            F={'s3'}
        )

    M1 = CreateDFA2aExactly()
    M2 = CreateDFA2bAtLeast()
    M3 = M2.Complement()
    M4 = M1.Union(M2)
    M5 = M1.Intersection(M2)

    for i, M in enumerate((M1, M2, M3, M4, M5), start=1):
        print()
        for w in ('a aa b bb bbb abba aab bbba babab abbbbaa'.split()+['']):
            print(f'''M{i}.Accept('{w}')={M.Accept(w)}''')
